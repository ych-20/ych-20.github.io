(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{382:function(d,n,e){"use strict";e.r(n);var l=e(46),t=Object(l.a)({},(function(){var d=this,n=d.$createElement,e=d._self._c||n;return e("ContentSlotsDistributor",{attrs:{"slot-key":d.$parent.slotKey}},[e("h1",{attrs:{id:"vue-中的-diff算法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue-中的-diff算法"}},[d._v("#")]),d._v(" Vue 中的 Diff算法")]),d._v(" "),e("hr"),d._v(" "),e("h2",{attrs:{id:"_2-x的diff算法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-x的diff算法"}},[d._v("#")]),d._v(" 2.x的Diff算法")]),d._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[d._v("diff算法是用于父节点相同，对子节点更新的一种算法。\n一下说明全部以如下情况为例子：   \n真实DOM： A | B | C | D | E | F | G \nold   ： A | B | C | D | E | F | G \nnew   ： A | B | D | E | I | C | F | G\n")])])]),e("h3",{attrs:{id:"比较步骤"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#比较步骤"}},[d._v("#")]),d._v(" 比较步骤")]),d._v(" "),e("p",[e("code",[d._v("通过双指针从两头往中间遍历：newStartIdx（oldStartIdx） 和 newEndIdx（oldEndIdx）")])]),d._v(" "),e("ul",[e("li",[d._v("新前 和 旧前比较\n"),e("ul",[e("li",[d._v("new A 和 old A 进行比较，相同则 newStartIdx++、oldStartIdx++。B同理")])])]),d._v(" "),e("li",[d._v("新后 和 旧后比较\n"),e("ul",[e("li",[d._v("new G 和 old G 进行比较，相同则 newEndIdx--、oldEndIdx--。F同理")])])]),d._v(" "),e("li",[d._v("新前 和 旧后比较\n"),e("ul",[e("li",[d._v("此时各个指针指向newStartIdx：D、newEndIdx：C、oldStartIdx：C、oldEndIdx：E")]),d._v(" "),e("li",[d._v("D 和 E 对比 不相同 进行下一步对比")])])]),d._v(" "),e("li",[d._v("新后 和 旧前比较\n"),e("ul",[e("li",[d._v("C 和 C 对比 相同 则 将真实DOM中C的位置移动到 oldEndIdx 的后面。 然后将 oldStartIdx++、newEndIdx--")]),d._v(" "),e("li",[d._v("此时各个指针指向newStartIdx：D、newEndIdx：I、oldStartIdx：D、oldEndIdx：E")]),d._v(" "),e("li",[d._v("继续newStartIdx开始重复 上述步骤")])])]),d._v(" "),e("li",[d._v("遍历旧数组进行查找(isSameNode) 如果找到 则进行移动 未找到则新增当前节点。\n"),e("ul",[e("li",[d._v("如果节点经过上述四种情况都没匹配上，则去遍历old 看是否 有节点和 newStartIdx 匹配，根据结果进行响应的 移动、删除、新增DOM操作")])])]),d._v(" "),e("li",[d._v("old先遍历完成 则将new中未遍历的节点 插入到真实DOM中。反之则删除odl未处理的节点对应的DOM节点")])]),d._v(" "),e("h2",{attrs:{id:"vue-3-x-中对于diff-算法的优化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue-3-x-中对于diff-算法的优化"}},[d._v("#")]),d._v(" Vue 3.x 中对于Diff 算法的优化")]),d._v(" "),e("ol",[e("li",[e("p",[d._v("分别从头尾开始遍历，找到第一个不匹配的项则停止进行下一步匹配。")]),d._v(" "),e("ul",[e("li",[d._v("从前往后匹配到B后结束 从后往前 匹配到F结束。这四个节点不需要移动")]),d._v(" "),e("li",[d._v("旧节点剩下未遍历DOM：C | D | E")]),d._v(" "),e("li",[d._v("新节点剩下未遍历DOM：D | E | I | C")])])]),d._v(" "),e("li",[e("p",[d._v("判断old是否遍历完，遍历完则将new中剩下的全部新增（mount）")])]),d._v(" "),e("li",[e("p",[d._v("判断new是否遍历完，遍历完则将old中剩下的全部删除（unmount）")])]),d._v(" "),e("li",[e("p",[d._v("剩下的中间内容为乱序")]),d._v(" "),e("ul",[e("li",[d._v("根据new剩下的节点生成一个key和index的map，keyToNewIndexMap[D:3,E:4,I:5,C:6]（5.1）")]),d._v(" "),e("li",[d._v("根据上述map生成一个等长的数组 newIndexToOldIndexMap[ 0, 0, 0, 0]（5.2）")]),d._v(" "),e("li",[d._v("遍历old去匹配keyToNewIndexMap 如果匹配到 则把 oldIdx + 1填充到新数组（newIndexToOldIndexMap）对应的地方去，\n未匹配到的节点就是需要删除的节点。找到了patch一下，最后 newIndexToOldIndexMap 为 [ 4, 5, 0, 3]。（5.3）")]),d._v(" "),e("li",[d._v("其实到这一步，已经很好办了，从尾到头循环一下newIndexToOldIndexMap\n是 0 的，说明是新增的数据，就 mount 进去\n非 0 的，说明在旧数据里，我们只要把它们移动到对应index的前面就行了\n但是这里还可以做一步优化（根据最长递增子序列 进行优化，即找到最长递增子序列[ 4, 5]不用移动 只需要新增0[I 到 DE后面]和移动3[C到I后]）")])])])])])}),[],!1,null,null,null);n.default=t.exports}}]);