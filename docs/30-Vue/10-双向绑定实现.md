# Vue 双向绑定简单实现
---
## 概述
```
双向绑定主要通过 Observer、Compiler、Watcher、Dep 四个模块来实现，
Observer通过 Object.defineProperty(Vue 3.x 通过proxy) 方法实现 对变量的劫持，
Wather 主要是进行 完成 数据改变后的响应操作，
Dep 用来收集Watcher,
Compiler 主要是进行模板编译，生成一个render()方法。
在模板编译时，在触发数据geter时 收集 Wacther 在数据改变时 通过Watcher 执行render()方法更新视图实现从数据到视图的绑定，
同时在模板编译时，监听视图的input事件，在input事件触发时，同时修改数据。实现从视图到数据的绑定，从而实现双向绑定。

// 双向绑定主要通过 Observer 对数据进行劫持，在模板编译（Compile）的时候，收集Watcher
// Vue 通过 Object.defineProperty(Vue 3.x 通过proxy)劫持变量的 geter 和 seter，
```
### Observer
* 遍历对象 进行劫持
* 在首次触发get 的时候 收集Watcher
* 触发 set 时 对收集的所有Watcher 通知更新
```js
export function observe(data) {
    if (typeof data === 'object') {
        for (const key in data) {
            observe(data[key])
            defineReactive(data, key,data[key])
        }
    }
}

function defineReactive(data, key,val) {
    const dep = new Dep()
    Object.defineProperty(data, key, {
        enumerable: true,
        configurable: true,
        get() {
            if (Dep.target) {
                dep.addSub(Dep.target)
            }
            return val
        },

        set(newVal) {
            if (val === newVal){
                return
            }
            val = newVal
            dep.notify()
        }
    })
}
```
### Watcher
* 目前只是一个简单的实现视图更新，所以只需要在更新时 执行cb（也就是compiler 生成的render函数）
* 每一个组件都对应着一个 watcher
```js
export default class Watcher {
    constructor(vm, exp, cb) {
        this.vm = vm
        this.exp = exp
        this.cb = cb
        // 目前只是 简单的实现 更新视图的响应  所以 并不需要 回调函数的值
        // this.value = this.cb
    }

    notify() {
        this.runner()
    }

    runner() {
        this.cb()
    }
}
```

### Dep
* 收集Watcher
```js
export default class Dep {
    constructor(vm) {
        this.vm = vm
        this.subs = []
    }
    addSub(watcher){
        this.subs.push(watcher)
    }
    notify(){
        this.subs.forEach(watcher =>{
            watcher.notify()
        })
    }
}

```

### Compiler
* 在首次实例化的时候 生成一个render方法  用于每次数据更改后，更新视图
* compileNode 方法只处理了 Text类型的节点  和 有v-model 属性的 input元素
* 只是简单的实现了一个 更新视图的方法，没有对事件进行处理，vue中会将dom 转化成AST，用虚拟节点的原理结合diff算法实现dom更新的操作，这里只是简单的达到效果即可。
```js
export default class Compiler {
    constructor(vm,el) {
        const fragment = document.createDocumentFragment()
        this.vm = vm
        el.childNodes.forEach(chNode =>{
            fragment.appendChild(chNode.cloneNode(true))
        })
        this.render = ()=>{
            const fragmentClone = fragment.cloneNode(true)
            this.compileNode(fragmentClone)
            el.innerHTML = ''
            el.appendChild(fragmentClone)
        }
    }
    compileNode(node){
        node.childNodes.forEach(chNode =>{
            console.log(chNode,chNode.childNodes)
            if (chNode.childNodes.length){
                this.compileNode(chNode)
            } else if (chNode.nodeType === Node.TEXT_NODE){
                // textContent 有多个 {{  }}  只会处理第一个  只简单实现一个 原理即可
                // '{{chNode.textContent}}  {{asdf21344}}'.replace(/\{\{(.+?)\}\}/g, (...args) => {
                chNode.textContent = chNode.textContent.replace(/\{\{(.+?)\}\}/g, (...args) => {
                    const dateKey = args[1].trim()
                    return this.vm.$data[dateKey]
                });
            }
        })
    }
}
```

### Vue
1. observe data，对data 进行一个劫持
2. 传入options 对el 进行 Compile 生成一个render 函数
3. 为当前组件 生成一个watcher 
4. 初始化时  执行一次render方法
```js
import Compiler from "./compiler.js";
import Watcher from "./watcher.js"
import Dep from "./dep.js";
import {observe} from "./observer.js";
export default class Vue {
    constructor(options) {
        const {el,data,mounted} = options
        this.$options = options
        this.$data = data
        this.$el = el
        observe(data)
        const compile = new Compiler(this,el)
        const watcher = new Watcher(this,'',compile.render)
        this.$watcher = watcher
        // 首次render 的时候 将组件对应的 watcher 加入 dep中
        Dep.target = watcher
        compile.render()
        Dep.target = null
        // mounted()
    }
}

// main.js
const vue = new Vue({
    el: document.querySelector("#app"),
    data:{
        name:'namenamenamenamename',
        age:'1234',
        input:'input'
    }
})
```
